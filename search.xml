<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>VSCode快捷键</title>
    <url>/blog/2023/VSCode%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>旨在少用鼠标/触摸板，避免分心。但是触摸板在快速定位，滚动屏幕和选中非完整行上比较方便。</p>
<p>设置快捷键：<code>Ctrl + K, Ctrl + S</code></p>
<span id="more"></span>
<h2 id="外观">外观</h2>
<p>打开关闭主侧边栏：<code>Ctrl + B</code></p>
<p>打开关闭下方面板：<code>Ctrl + J</code></p>
<p>打开侧边预览：<code>Ctrl + K, V</code></p>
<p>进入退出禅模式：<code>Ctrl + K, Z</code></p>
<p>切换选项卡：<code>Ctrl + Tab</code></p>
<h2 id="光标与选择">光标与选择</h2>
<p>选择：<code>Shift + 方向键</code></p>
<p>快速选中一行：<code>Ctrl + L</code></p>
<p>向下选中多行：继续按<code>Ctrl + L</code></p>
<p>选中多行：光标移动到行首，然后<code>Shift + 上下</code></p>
<p>光标移动到行首：<code>Fn + 左</code></p>
<p>从光标处选中到行首：<code>Shift + Fn + 左</code></p>
<p>按单词移动光标：<code>Ctrl + 左右</code></p>
<p>滚动屏幕，光标处于原位置：<code>Ctrl + 上下</code></p>
<h2 id="编辑">编辑</h2>
<p>格式化文档：<code>Shift + ALt + F</code></p>
<p>注释/取消注释：<code>Ctrl + /</code></p>
<p>快速复制一行：<code>Shift + Alt + 上下</code></p>
<p>移动行：<code>Alt + 上下</code></p>
<p>按行号跳转：<code>Ctrl + G</code></p>
<p>快速删除一行：<code>Ctrl + Shift + K</code></p>
<p>删除一行并保留空行：<code>Fn + 右, Shift + Fn + 左 , Backspace</code></p>
<h2 id="查找替换">查找替换</h2>
<p>查找框：<code>Ctrl + F</code></p>
<p>查找框上的按钮：</p>
<ul>
<li><p>区分大小写：<code>Alt + C</code></p></li>
<li><p>全字匹配：<code>Alt + W</code></p></li>
<li><p>正则表达式：<code>Alt + R</code></p></li>
<li><p>下一个：<code>Enter</code></p></li>
<li><p>上一个：<code>Shift + Enter</code></p></li>
<li><p>在选定内容中查找：<code>Alt + L</code></p></li>
</ul>
<p>替换框：<code>Ctrl + H</code></p>
<p>替换框上的按钮：</p>
<ul>
<li><p>替换：<code>Enter</code></p></li>
<li><p>全部替换：<code>Shift + Enter</code></p></li>
</ul>
<p>关闭查找替换框：<code>Esc</code></p>
]]></content>
      <categories>
        <category>探索</category>
      </categories>
  </entry>
  <entry>
    <title>JSON</title>
    <url>/blog/2023/JSON/</url>
    <content><![CDATA[<p>JSON(JavaScript Object
Notation，JavaScript对象表示法)是一种轻量级的数据交换格式。
<span id="more"></span></p>
<h2 id="json与js对象互转">json与js对象互转</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// js对象转json字符串</span></span><br><span class="line">json = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// json字符串转js对象</span></span><br><span class="line">obj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(json)</span><br></pre></td></tr></table></figure>
<h2 id="使用python编解码json">使用Python编解码json</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">dic = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编码</span></span><br><span class="line">string = json.dumps(dic)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码</span></span><br><span class="line">dic = json.loads(string)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>概念</category>
      </categories>
  </entry>
  <entry>
    <title>《草蛇惊一》歌词解读</title>
    <url>/blog/2023/%E3%80%8A%E8%8D%89%E8%9B%87%E6%83%8A%E4%B8%80%E3%80%8B%E6%AD%8C%E8%AF%8D%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>《草蛇惊一》收录于初音未来 V4C 专辑《初梦》，作词是<a
href="https://space.bilibili.com/396967">麦当叔劳劳</a>。</p>
<span id="more"></span>
<p><a href="https://www.bilibili.com/video/BV1Px41177ht/">去 B
站观看</a> | 在线听：</p>
<iframe frameborder="no" width="100%" height="86" src="//music.163.com/outchain/player?type=2&amp;id=515455714&amp;auto=1&amp;height=66">
</iframe>
<p>这种歌词应该属于“意识流”。解读需要把自己代入主人公的视角。一千个读者心中有一千个哈姆雷特，我认为歌词写的是主人公内心的矛盾。</p>
<p>歌词结构：</p>
<p>主歌一-&gt;主歌二-&gt;导歌-&gt;副歌-&gt;</p>
<p>主歌二-&gt;导歌-&gt;副歌-&gt;</p>
<p>改词的副歌-&gt;副歌-&gt;重复副歌最后一句</p>
<h2 id="歌名">歌名</h2>
<p>很容易从歌名联想到“打草惊蛇”。</p>
<p>我认为“草蛇惊一”的“一”是指打草的人。</p>
<p>在这里，草、蛇和打草的人都是主人公自己——主人公自己惊动了自己。</p>
<h2 id="主歌一">主歌一</h2>
<blockquote>
<p><em>羡慕风车 不必去四海漂泊 只要能在原地旋转便能体会风的快乐</em></p>
</blockquote>
<p>第一句最重要，是起因。</p>
<p>主人公的内心独白。我们把主人公此时的视角记作“视角 A”。</p>
<p>“风车”有三层意思：</p>
<ol type="1">
<li>指被“风”驱动的人或物。</li>
<li>指《堂吉诃德》里的风车所指，即假想敌。</li>
<li>指主人公自己。</li>
</ol>
<p>在刚开始，主人公认为“风车”是第一层意思，后来认识到了第二层意思。在经过多次反思后，才认识到了第三层意思。</p>
<p>至于“风”这个意象（能指），可以结合以下几首歌理解：</p>
<p>（原谅我开始报菜名，因为我还没法做到既简单、又准确的描述）</p>
<blockquote>
<ul>
<li><p>草东没有派对《大风吹》：<em>“大<strong>风</strong>吹着谁 谁就倒霉”</em></p></li>
<li><p>崔健《酷瓜树》：<em>“泥土带着<strong>风</strong> 闻着新鲜 让人沉睡”</em></p></li>
<li><p>ilem《白鸟过河滩》：<em>“<strong>风</strong>把我不想知道的事情告诉我”</em></p></li>
<li><p>ilem《斩草歌》：<em>“腐草迎<strong>风</strong>遮望眼 对错凭谁”</em></p></li>
<li><p>ilem《石头歌》：<em>“太阳落月亮升 旧血肉化成<strong>风</strong> 只有石头一动不动”</em></p></li>
<li><p>ilem《我没有歌能给你听》：<em>“一些流浪的<strong>风</strong> 一些景色”</em></p></li>
</ul>
</blockquote>
<p>“原地旋转”就是不作出改变，变成石头，最后变成流浪的风。</p>
<blockquote>
<p><em>及时行乐 外婆的故事里说因果报应乃白日见鬼</em></p>
</blockquote>
<p>视角 A 想要把自己的人生观向“风车”靠拢。</p>
<blockquote>
<p><em>转折 没曾想单木不林一丝不线如我 孤单的说书者也能偷乐</em></p>
</blockquote>
<p>主人公突然转换为上帝视角，把自己代入说书者。这样就像看电影一样，不用再担心各种现实问题了。</p>
<blockquote>
<p><em>相濡以沫不如相忘于江湖 外公总说这是他孤单的借口</em></p>
</blockquote>
<p>进一步妄想自己是“相忘于江湖”的鱼，逃避现实。</p>
<h2 id="主歌二">主歌二</h2>
<blockquote>
<p><em>放轻松 压力别弄得太大 飘飘欲仙欲死不知是不是自己的风格</em></p>
</blockquote>
<p>主人公认为自己逃避现实是不对的，此时视角转换回了视角 A。</p>
<p>前半部分是视角 A 对自己说的，后半部分是视角 A 对说书者说的。</p>
<blockquote>
<p><em>一语道破 下手斩草除根哭吧哭吧 无聊卑微笑话</em></p>
</blockquote>
<p>视角
A“一语道破”了说书者的伪装，并否定掉了风车的人生观。认为有这种想法的自己是“无聊卑微笑话”。</p>
<blockquote>
<p><em>音色也在不知不觉中变得低沉 就像患了名为暴躁的病一样</em></p>
</blockquote>
<p>主人公在否定自己之后，风车的一面并没有消失，而是在反噬视角 A。</p>
<blockquote>
<p><em>快停止吧 那张顽固蠢蛋的终身证明我不想再去想念</em></p>
</blockquote>
<p>风车和视角 A
在脑海里互相争斗。主人公希望自己不要再胡思乱想了，给自己开了“顽固蠢蛋的终身证明”。</p>
<h2 id="导歌">导歌</h2>
<blockquote>
<p><em>一不做二不休自在风流 乐不思蜀子龙我就不走</em></p>
</blockquote>
<p>对于一件事，我要么不做，要么就做到最好，我觉得这样太酷啦；</p>
<p>赵云救了刘禅最终导致乐不思蜀，这让我怎么做接下来每一步的决定呢？干脆不做了。</p>
<blockquote>
<p><em>过五关杀六将公子献头 金蝉脱壳孙老头八十二变我有</em></p>
</blockquote>
<p>主人公一会儿代入关羽，一会儿代入荆轲/太子丹。并预想了像他们一样做事之后的结果。</p>
<p>“金蝉脱壳”指主人公抽离自己为说书者。</p>
<p>“孙老头八十二变”指思想转换的复杂性。</p>
<blockquote>
<p><em>百闻不如一见来翻筋斗 福星高照五湖四海都随我漫步遨游
山雨欲来风满楼</em></p>
</blockquote>
<p>终于要作决定了！但是在做出决定之前的继续妄想，构成了主人公脑海里的狂风。</p>
<h2 id="副歌">副歌</h2>
<blockquote>
<p><em>再见吧 提线的傀儡师 耻笑咚咚跳的心脏和那不实际的憧憬</em></p>
</blockquote>
<p>傀儡是身体，傀儡师是幻想。主人公向对自己造成心惊肉跳的幻想作别。</p>
<blockquote>
<p><em>玩笑吧 我不想听假话 暴露皆大欢喜不攻自破不成熟的笑话</em></p>
</blockquote>
<p>主人公给自己的 EQ 开了低通滤波。</p>
<blockquote>
<p><em>怠慢吗 或许只是懈怠吧 嘁嘁咔咔咚咚咭咭再也不想它</em></p>
</blockquote>
<p>主人公认为，这都是由自己的“怠慢”或者“懈怠”造成的。在又一番思想斗争之后停止了思考。</p>
]]></content>
      <categories>
        <category>共鸣</category>
      </categories>
  </entry>
  <entry>
    <title>root手机教程（使用Magisk）</title>
    <url>/blog/2023/root%E6%89%8B%E6%9C%BA%E6%95%99%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8Magisk%EF%BC%89/</url>
    <content><![CDATA[<p>你需要：</p>
<ul>
<li>一台系统为 Android 6.0 以上的手机</li>
<li>一台能够正常使用 <a
href="https://developer.android.google.cn/studio/releases/platform-tools?hl=zh-cn">Android
SDK Platform-Tools</a> 的电脑</li>
</ul>
<span id="more"></span>
<p>另外，如果你手机的Android kernel版本在5.10以上，你也可以使用<a
href="https://kernelsu.org/zh_CN/">KernelSU</a>——这不属于此教程的范围。</p>
<h2 id="背景知识">背景知识</h2>
<h3 id="linux-与-android">Linux 与 Android</h3>
<p>Linux是一种操作系统内核，由Linus
Torvalds开发。<strong>基于Linux内核</strong>，Android
Inc.公司开发出了Android操作系统。</p>
<p>2005年，Google收购Android
Inc.。2007年，Google将Android的源代码公开，并创建了<a
href="https://source.android.google.cn/?hl=zh-cn">AOSP</a>（Android Open
Source Project）项目。</p>
<p>许多手机厂商的定制系统，如MIUI、Flyme、HarmonyOS等都是<strong>基于AOSP源码</strong>开发的。和AOSP对标的<a
href="https://gitee.com/openharmony">OpenHarmony</a>也有用到Linux内核。所以，如果你的手机不是苹果，它里面大概率就会有一个修改过的Linux内核。</p>
<h3 id="linux-与-android-中的用户权限">Linux 与 Android
中的用户权限</h3>
<p>Linux操作系统是多用户操作系统，用户<code>root</code>拥有最高权限——对系统的完全控制权。拥有root权限的用户可以把其他用户添加到root用户组。在root用户组里，每个用户都有root权限。</p>
<p>在Android操作系统中，<strong>每个应用（APP）都是一个独立的用户</strong>。如果没有<code>root</code>用户把APP添加到root用户组，就没有APP能够获得root权限。</p>
<p>而在正常情况下，你在手机上见到的所有画面都是APP的进程（比如系统界面是<code>com.android.systemui</code>）。这时想要获得root权限，就需要修改更底层的东西。</p>
<h3 id="bootloader锁">Bootloader锁</h3>
<p>Bootloader，即启动引导加载程序。它负责在计算机启动时，引导操作系统加载。</p>
<p>在bootloader执行的过程中，如果签名验证未通过，说明系统底层文件被修改。这时bootloader会停止执行，<strong>无法进入系统</strong>。这被称为bootloader（BL）锁。</p>
<h3 id="magisk">Magisk</h3>
<p>The <strong>Magic Mask</strong> for
Android，是一套用于定制Android的开源软件。它可以为应用程序提供 root
访问权限。后文简称<strong>面具</strong>。</p>
<p>面具获取root权限的原理是通过修改boot分区，代理linux内核的第一个进程init。<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></p>
<p>面具修改了系统分区。因此，使用面具的前提是解除BL锁。</p>
<h2 id="准备工作">准备工作</h2>
<h3 id="解除bl锁">解除BL锁</h3>
<blockquote>
<p>解锁 BootLoader 实际上就是让 BootLoader
启动链上某些阶段的签名验证不生效。<a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
</blockquote>
<p>你需要在你手机厂商的网站上申请解锁码，然后用他们提供的工具解锁。有一些厂商（华为等）已经不提供解锁码。</p>
<p>注意：解锁BL后会<strong>清除所有用户数据，恢复出厂设置</strong>。请提前做好你重要文件的备份。</p>
<h3 id="提取boot.img">提取boot.img</h3>
<p>在网上搜索，找到你手机的安装包。</p>
<p>通常是一个<code>.zip</code>或.<code>tgz</code>格式的压缩包。确保手机型号一致、操作系统版本一致。</p>
<p>解压后找到<code>boot.img</code>或者<code>init_boot.img（如果有）</code>。复制两份，分别保存到手机和电脑，备用。</p>
<ul>
<li>如果你找不到<code>boot.img</code>，而找到了<code>payload.bin</code>：参考<a
href="https://magiskcn.com/payload-dumper-go-boot">这篇教程</a>。或者使用<a
href="https://mt2.cn/">MT管理器</a>提取。</li>
<li>如果你的手机<em><strong>已经root了</strong></em>：可以在<code>adb shell</code>下使用<code>ls -l /dev/block/by-name/</code>查看分区表。找到boot分区，比如<code>/dev/block/sdc41</code>。使用<code>dd if=/dev/block/sdc41 of=/sdcard/boot.img</code>提取boot分区。</li>
</ul>
<h3 id="通过usb调试手机">通过USB调试手机</h3>
<p>在手机设置里找到系统版本（比如MIUI，是在“全部参数”里的“MIUI版本”）。连续点击，直到手机出现提示框“您现在处于开发者模式”。</p>
<p>在手机设置里找到开发者选项，进入。找到<strong>USB调试</strong>选项并开启。</p>
<p>下载<a
href="https://developer.android.google.cn/studio/releases/platform-tools?hl=zh-cn">Android
SDK
Platform-Tools</a>，解压到你喜欢的目录。比如<code>D:\platform-tools</code>。你会看到目录里有<code>adb.exe</code>和<code>fastboot.exe</code>等一些文件。</p>
<p>打开命令行（Windows下win+R输入cmd，回车），你会看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\你的用户名\&gt;</span><br></pre></td></tr></table></figure>
<p>这是你当前所在的目录。当你要执行一个<code>.exe</code>文件时，系统先从当前目录里寻找。如果找不到，就从环境变量里寻找。再找不到就打印错误信息。</p>
<p>你刚才解压出来的<code>.exe</code>文件只能在它们所在的目录下运行。如果不想切换目录，想让它们在任意目录下都可以运行，需要把它们<strong>所在的目录</strong>添加到<strong>环境变量</strong>。</p>
<p>Windows
10下，<code>Win + I</code>打开设置。系统-&gt;关于-&gt;高级系统设置-&gt;环境变量，双击系统变量<code>Path</code>，新建，把<code>D:\platform-tools</code>复制到列表，确定确定确定。这样环境变量就设置好了。</p>
<p>用数据线连接手机和电脑。你可以尝试在<code>cmd</code>里使用命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>
<p>这时手机会弹出授权窗口。点击确定，你会在电脑上看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">你手机的序列号        device</span><br></pre></td></tr></table></figure>
<p>说明adb连接成功。</p>
<h2 id="戴上面具">戴上面具</h2>
<p><a
href="https://github.com/topjohnwu/Magisk/releases">下载面具</a>并安装打开，你将看到：</p>
<p><img src="/blog/images/magisk.webp"></p>
<p>如果Ramdisk为<strong>否</strong>，或者你的手机品牌是<strong>华为</strong>或<strong>三星</strong>：参考
<a
href="https://jesse205.github.io/MagiskChineseDocument/install.html">Magisk
中文文档</a>。</p>
<p>点击“安装”按钮。如果你手机的安装包中有<code>vbmeta.img</code>，选中“修补
boot 映像中的 vbmeta”选项。否则不选中。</p>
<p>在方式中选择“选择并修补一个文件”。然后选择你提取出来的<code>boot.img</code>或<code>init_boot.img</code>。点击“安装”。</p>
<p>面具会把修补后的文件<code>magisk_patched-[版本号_随机字符].img</code>存放到SD卡的<code>Download</code>目录下。</p>
<p>把修补后的文件复制到电脑：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb pull /sdcard/Download/magisk_patched-[版本号_随机字符].img 电脑上的一个文件夹路径</span><br></pre></td></tr></table></figure>
<p>重启手机到<code>fastboot</code>模式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure>
<p>刷写新的<code>boot</code>分区：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fastboot flash boot（或者init_boot） 电脑上的一个文件夹路径\magisk_patched-[版本号_随机字符].img</span><br></pre></td></tr></table></figure>
<p>重启手机：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure>
<p>打开面具。如果看到了Magisk-&gt;当前的版本号，说明成功。</p>
<ul>
<li><p>如果你的手机打不开了：说明面具不适合你的手机，或者你有地方做错了。
你需要长按【电源】键重启，然后马上同时按住【电源】键和【音量+】键（也有手机是【电源】键和【音量-】键）。这会把手机重启到<code>fastboot</code>模式。
然后使用以下命令恢复boot分区： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fastboot flash boot（或者init_boot） 电脑上的一个文件夹路径\你修补前的boot.img</span><br></pre></td></tr></table></figure></p></li>
<li><p>在安装面具后：需要禁用系统自动更新。<a
href="#后续处理更新系统时">后续处理——更新系统时</a></p></li>
</ul>
<h2 id="隐藏面具">隐藏面具</h2>
<p>为了用户安全，一些银行类的app在检测到root后会禁止用户使用。需要对这一类app隐藏root。</p>
<h3 id="使用shamiko隐藏root">使用Shamiko隐藏root</h3>
<p>Shamiko是一个面具模块，用于隐藏root。</p>
<ul>
<li>如果使用的是<a
href="https://github.com/magojohnji/Magisk-delta/blob/main/intro.md">Magisk
Delta</a>，则不能安装此模块。可用其内置的MagiskHide。</li>
</ul>
<p>在面具设置里：</p>
<ul>
<li><p>找到“Zygisk”，<strong>开启</strong>。</p></li>
<li><p>找到“遵守排除列表”，<strong>关闭</strong>。</p></li>
<li><p>找到“配置排除列表”，选择要对其隐藏root的应用。点击，在展开的列表里全部打上勾，直到上方进度条满。</p></li>
</ul>
<p><a
href="https://github.com/LSPosed/LSPosed.github.io/releases/">下载Shamiko</a>
。打开面具-&gt;模块-&gt;从本地安装-&gt;选择下载的<code>shamiko-[版本号]-release.zip</code>-&gt;确定-&gt;重启手机。</p>
<p>如果看到模块-&gt;Shamiko的简介里露出了😋，说明Shamiko正常运行。</p>
<h3 id="使用随机包名隐藏面具应用">使用随机包名隐藏面具应用</h3>
<p>面具设置-&gt;隐藏Magisk应用</p>
<h2 id="后续处理更新系统时">后续处理——更新系统时</h2>
<p>系统更新前：先打开面具，选择“卸载Magisk”-&gt;<strong>还原原厂映像</strong>。然后更新系统。</p>
<p>系统更新后：仍然使用提取boot-&gt;修补boot-&gt;刷入boot的方式安装面具。</p>
<ul>
<li>如果希望在更新系统时保留面具：参考<a
href="https://jesse205.github.io/MagiskChineseDocument/ota.html">这篇文档</a>。</li>
</ul>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="https://mp.weixin.qq.com/s/eF9izvazeSZ1bVxOcxamQg">何为root？维术：https://mp.weixin.qq.com/s/eF9izvazeSZ1bVxOcxamQg</a><a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a
href="https://mp.weixin.qq.com/s/-9VKyraHq5Qt2PTzqVqZOg">当我们谈论解锁
BootLoader
时，我们在谈论什么？维术：https://mp.weixin.qq.com/s/-9VKyraHq5Qt2PTzqVqZOg</a><a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
  </entry>
  <entry>
    <title>乐理-A0-频率与音程</title>
    <url>/blog/2023/%E4%B9%90%E7%90%86-A0-%E9%A2%91%E7%8E%87%E4%B8%8E%E9%9F%B3%E7%A8%8B/</url>
    <content><![CDATA[<ul>
<li>钢琴琴键的声音频率</li>
<li>音程与升降号</li>
<li>音程速查表</li>
<li>用 Python 写一个程序，输入 88 键钢琴的任一音名，输出对应的频率</li>
</ul>
<span id="more"></span>
<h2 id="声音的频率">声音的频率</h2>
<p>声音是由声源振动产生的，通过机械波传递。</p>
<p>声音的频率就是机械波的频率，也是声源振动的频率。</p>
<p>比如声源振动 <span class="math inline">\(440\)</span>
次每秒，频率就是 <span
class="math inline">\(440\mathrm{Hz}\)</span>。“每秒”这个单位 <span
class="math inline">\(\mathrm{s^{-1}}\)</span> 也记作赫兹 <span
class="math inline">\(\mathrm{Hz}\)</span>，是国际单位制“秒”的导出单位。</p>
<p>暂时先不管“基频”、“泛频”等概念。</p>
<h2 id="钢琴琴键的声音频率">钢琴琴键的声音频率</h2>
<ol type="1">
<li><p>规定一个基准频率，比如 <span
class="math inline">\(440\mathrm{Hz}\)</span>，作为第一个音。</p></li>
<li><p>把第一个音的频率乘上 <span
class="math inline">\(\sqrt[12]{2}\)</span>，就得到第二个音。一直乘，乘了十二次之后，第十三个音的频率正好是第一个音频率的两倍。</p>
<p>这十三个音把一个 <span class="math inline">\(1:2\)</span>
的频率区间分成了十二个部分，每个音的频率都是对应部分的端点，相邻两音的频率比为
<span
class="math inline">\(1:\sqrt[12]{2}\)</span>。这就是十二平均律。</p></li>
<li><p>如果把第一个音（<span
class="math inline">\(440\mathrm{Hz}\)</span>）记作<code>A4</code>，往前乘十二次，得到
<span class="math inline">\(880\mathrm{Hz}\)</span>
的音，就记作<code>A5</code>。同理，再乘十二次，得到 <span
class="math inline">\(1760\mathrm{Hz}\)</span> 就是<code>A6</code>。</p>
<p>还可以往后除，<span class="math inline">\(220\mathrm{Hz}\)</span>
是<code>A3</code>，<span class="math inline">\(110\mathrm{Hz}\)</span>
是<code>A2</code>。</p>
<p>同理。<span class="math inline">\(27.5\mathrm{Hz}\)</span>
是<code>A0</code>，<span class="math inline">\(3520\mathrm{Hz}\)</span>
是<code>A7</code>。</p>
<p><code>A7</code>再往前乘三次，得到频率为 <span
class="math inline">\(3520 \times \sqrt[4]{2} \mathrm{Hz}\)</span>
的音，记作<code>C8</code>。</p></li>
<li><p>从<code>A0</code>到<code>C8</code>，有 88 个音，频率构成首项为
<span class="math inline">\(27.5\)</span>，公比为 <span
class="math inline">\(\sqrt[12]{2}\)</span> 的等比数列。这就是 88
键钢琴每个琴键的频率。</p></li>
</ol>
<p>上面是规定 <span class="math inline">\(\mathrm{A4=440Hz}\)</span>
时，还可以有其他规定。</p>
<h2 id="音程">音程</h2>
<p>两个音之间的频率比，称为音程。</p>
<p>频率比为 <span class="math inline">\(1:2\)</span>
的两个音之间，音程称为一个<strong>纯八度</strong>（简称八度）。</p>
<p>快速认识钢琴一个八度里的音：</p>
<p><img src="/blog/images/piano.webp"></p>
<p>为什么这么命名，先别管。</p>
<p>两个相邻琴键的频率比，比如<code>C4</code>和<code>C#4</code>之间，频率比为
<span
class="math inline">\(1:\sqrt[12]{2}\)</span>，称为一个<strong>半音</strong>。也叫小二度。</p>
<p>两个琴键相隔一个琴键的频率比，比如<code>C4</code>和<code>D4</code>之间，频率比为
<span
class="math inline">\(1:\sqrt[6]{2}\)</span>，称为两个半音。也叫一个<strong>全音</strong>或大二度。</p>
<h2 id="音程速查表">音程速查表</h2>
<p>“一四五八无大小，二三六七没有纯”</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="header">
<th>相隔半音数</th>
<th>音程名（纯）</th>
<th>音程名（大）</th>
<th>音程名（小）</th>
<th>音程名（增）</th>
<th>音程名（减）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>纯一度</td>
<td></td>
<td></td>
<td></td>
<td>减二度</td>
</tr>
<tr class="even">
<td>1</td>
<td></td>
<td></td>
<td>小二度</td>
<td>增一度</td>
<td></td>
</tr>
<tr class="odd">
<td>2</td>
<td></td>
<td>大二度</td>
<td></td>
<td></td>
<td>减三度</td>
</tr>
<tr class="even">
<td>3</td>
<td></td>
<td></td>
<td>小三度</td>
<td>增二度</td>
<td></td>
</tr>
<tr class="odd">
<td>4</td>
<td></td>
<td>大三度</td>
<td></td>
<td></td>
<td>减四度</td>
</tr>
<tr class="even">
<td>5</td>
<td>纯四度</td>
<td></td>
<td></td>
<td>增三度</td>
<td></td>
</tr>
<tr class="odd">
<td>6</td>
<td></td>
<td></td>
<td></td>
<td>增四度</td>
<td>减五度</td>
</tr>
<tr class="even">
<td>7</td>
<td>纯五度</td>
<td></td>
<td></td>
<td></td>
<td>减六度</td>
</tr>
<tr class="odd">
<td>8</td>
<td></td>
<td></td>
<td>小六度</td>
<td>增五度</td>
<td></td>
</tr>
<tr class="even">
<td>9</td>
<td></td>
<td>大六度</td>
<td></td>
<td></td>
<td>减七度</td>
</tr>
<tr class="odd">
<td>10</td>
<td></td>
<td></td>
<td>小七度</td>
<td>增六度</td>
<td></td>
</tr>
<tr class="even">
<td>11</td>
<td></td>
<td>大七度</td>
<td></td>
<td></td>
<td>减八度</td>
</tr>
<tr class="odd">
<td>12</td>
<td>纯八度</td>
<td></td>
<td></td>
<td>增七度</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="升降号">升降号</h2>
<p><span class="math inline">\(\sharp\)</span>
为升号（sharp），用于把一个音升高半音。</p>
<p>比如 <span class="math inline">\(\mathrm{B \sharp 4 =
C5}\)</span>。<code>B#4 = C5</code></p>
<p><span class="math inline">\(\flat\)</span>
为降号（flat），用于把一个音降低半音。</p>
<p>比如 <span class="math inline">\(\mathrm{D \flat 4 = C \sharp
4}\)</span>。<code>Db4 = C#4</code></p>
<h2 id="作业">作业</h2>
<p>用 Python 写一个程序，输入 88
键钢琴的任一音名，输出对应的频率。当输入<code>all</code>时，输出所有音的频率。（<span
class="math inline">\(\mathrm{A4=440Hz}\)</span>，白键不加升降号，黑键始终为升号，保留三位小数）</p>
<p><strong>仅供参考的答案</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这部分代码用于生成包含钢琴88个音的字符串元组，把输出的结果单独保存到一个文件 my_constants.py 里。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">oks = octave_keys = (<span class="string">&quot;C&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;D#&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;F#&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="string">&quot;G#&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;A#&quot;</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">pks = piano_keys = [<span class="string">&quot;A0&quot;</span>, <span class="string">&quot;A#0&quot;</span>, <span class="string">&quot;B0&quot;</span>]</span><br><span class="line">pks.extend([key + <span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">8</span>) <span class="keyword">for</span> key <span class="keyword">in</span> oks])</span><br><span class="line">pks.extend([<span class="string">&quot;C8&quot;</span>])</span><br><span class="line">pks = <span class="built_in">tuple</span>(pks)</span><br><span class="line"><span class="built_in">print</span>(pks)</span><br></pre></td></tr></table></figure>
<p><code>main.py</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> my_constants <span class="keyword">import</span> PIANO_KEYS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PianoKeyFreq</span>:</span><br><span class="line">    pianokey_freq: <span class="built_in">dict</span>  <span class="comment"># 存放音名频率的字典</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        生成音名频率字典</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.pianokey_freq = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> PIANO_KEYS:</span><br><span class="line">            self.pianokey_freq[key] = self.calc_frequency(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calc_frequency</span>(<span class="params">self, alphabet: <span class="built_in">str</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算音名的频率，音名需要已经在88键钢琴内</span></span><br><span class="line"><span class="string">        返回频率</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 基准频率</span></span><br><span class="line">        F_A4 = <span class="number">440</span></span><br><span class="line">        <span class="comment"># 计算相隔的半音数</span></span><br><span class="line">        semitones = PIANO_KEYS.index(alphabet) - PIANO_KEYS.index(<span class="string">&quot;A4&quot;</span>)</span><br><span class="line">        <span class="comment"># 计算频率</span></span><br><span class="line">        f_alphabet = F_A4 * <span class="number">2</span> ** (semitones / <span class="number">12</span>)</span><br><span class="line">        <span class="keyword">return</span> f_alphabet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintPianoKeyFreq</span>(<span class="title class_ inherited__">PianoKeyFreq</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_freq</span>(<span class="params">self, alphabet: <span class="built_in">str</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        输出一个音名对应的频率</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            f_alphabet = self.pianokey_freq[alphabet]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;alphabet&#125;</span> 的频率是 <span class="subst">&#123;f_alphabet:<span class="number">.3</span>f&#125;</span>Hz&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;找不到音名，输入 all 以查看所有音名的频率&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_all_freq</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        输出所有音名对应的频率</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.pianokey_freq.items():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;k:&gt;<span class="number">3</span>&#125;</span> 的频率是 <span class="subst">&#123;v:<span class="number">.3</span>f&#125;</span>Hz&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ppkf = PrintPianoKeyFreq()</span><br><span class="line">    inpu = <span class="built_in">input</span>(<span class="string">&quot;输入音名：&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> inpu == <span class="string">&quot;all&quot;</span>:</span><br><span class="line">        ppkf.print_all_freq()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ppkf.print_freq(inpu)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>概念</category>
      </categories>
  </entry>
  <entry>
    <title>十进制与K进制小数互转</title>
    <url>/blog/2023/%E5%8D%81%E8%BF%9B%E5%88%B6%E4%B8%8EK%E8%BF%9B%E5%88%B6%E5%B0%8F%E6%95%B0%E4%BA%92%E8%BD%AC/</url>
    <content><![CDATA[<ul>
<li>K 转 10：和整数进制转换的方法一样</li>
<li>10 转 K：乘 K 取整</li>
</ul>
<span id="more"></span>
<h2 id="k-转-10和整数进制转换的方法一样">K 转
10：和整数进制转换的方法一样</h2>
<p>每一位分别乘上 K 的次方，再相加。</p>
<h3 id="转-10">2 转 10</h3>
<h4 id="有限小数">有限小数</h4>
<p><span class="math inline">\(11.1011_{2} = 3.6875_{10}\)</span></p>
<table>
<thead>
<tr class="header">
<th>项</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(1\times2^{1}\)</span></td>
<td><span class="math inline">\(2\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(1\times2^{0}\)</span></td>
<td><span class="math inline">\(1\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(1\times2^{-1}\)</span></td>
<td><span class="math inline">\(0.5\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(0\times2^{-2}\)</span></td>
<td><span class="math inline">\(0\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(1\times2^{-3}\)</span></td>
<td><span class="math inline">\(0.125\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(1\times2^{-4}\)</span></td>
<td><span class="math inline">\(0.0625\)</span></td>
</tr>
<tr class="odd">
<td><strong>总和</strong></td>
<td><span class="math inline">\(3.6875\)</span></td>
</tr>
</tbody>
</table>
<h4 id="无限循环小数">无限循环小数</h4>
<p><span class="math inline">\(1.1 \dot{0} 11 \dot{0} ... _{2} =
1.7_{10}\)</span></p>
<p>可以转换成分数计算：</p>
<p><span class="math display">\[
\begin{aligned}
1.1 \dot{0} 11 \dot{0} ... _{2} &amp; = x \\
11.\dot{0} 11 \dot{0} ... _{2} &amp; = 2_{10}x \\
110110. \dot{0} 11 \dot{0} ... _{2} &amp; = 32_{10}x \\
两式相减，110011_{2} &amp; = 30_{10}x \\
x &amp; = \frac{110011_{2}}{30_{10}} = \frac{51_{10}}{30_{10}} =
1.7_{10}
\end{aligned}
\]</span></p>
<h3 id="转-10-1">16 转 10</h3>
<p>同上略。</p>
<h2 id="转-k乘-k-取整">10 转 K：乘 K 取整</h2>
<p>整数部分仍然除 K 取余，小数部分乘 K 取整，然后相加。</p>
<h3 id="转-2">10 转 2</h3>
<p><span class="math inline">\(0.7 _{10} = 0.1 \dot{0} 11 \dot{0} ...
_{2}\)</span></p>
<table>
<thead>
<tr class="header">
<th>小数部分乘 2</th>
<th>取整数部分</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(0.7 \times 2 = 1.4\)</span></td>
<td><span class="math inline">\(1\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(0.4 \times 2 = 0.8\)</span></td>
<td><span class="math inline">\(0\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(0.8 \times 2 = 1.6\)</span></td>
<td><span class="math inline">\(1\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(0.6 \times 2 = 1.2\)</span></td>
<td><span class="math inline">\(1\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(0.2 \times 2 = 0.4\)</span></td>
<td><span class="math inline">\(0\)</span></td>
</tr>
<tr class="even">
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<h3 id="转-16">10 转 16</h3>
<p><span class="math inline">\(0.7 _{10} = 0.\mathrm{B} \dot{3} ...
_{16}\)</span></p>
<table>
<thead>
<tr class="header">
<th>小数部分乘 16</th>
<th>取整数部分</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(0.7 \times 16 = 11.2\)</span></td>
<td><span class="math inline">\(\mathrm{B}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(0.2 \times 16 = 3.2\)</span></td>
<td><span class="math inline">\(3\)</span></td>
</tr>
<tr class="odd">
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>探索</category>
      </categories>
  </entry>
  <entry>
    <title>在Windows中安装Linux虚拟机</title>
    <url>/blog/2023/%E5%9C%A8Windows%E4%B8%AD%E8%BF%90%E8%A1%8CLinux%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<ul>
<li>真机系统：Windows 10</li>
<li>使用软件：VMware Workstation 17.0.2 Player</li>
<li>虚拟机系统：Ubuntu 22.04.3 server</li>
</ul>
<span id="more"></span>
<p>也可以给硬盘分一个新的区，单独安装 Linux。不过没有必要。</p>
<h2 id="下载安装-vmware-workstation-player">下载安装 VMware Workstation
Player</h2>
<blockquote>
<p>使用 VMware Workstation Player 在 Windows 或 Linux PC
上轻松地将多个操作系统作为虚拟机运行。——网站介绍</p>
</blockquote>
<p><a
href="https://customerconnect.vmware.com/cn/downloads/info/slug/desktop_end_user_computing/vmware_workstation_player/">下载页面</a></p>
<p>这里下载的是当前最新版
<code>VMware Workstation 17.0.2 Player for Windows 64-bit Operating Systems</code>。</p>
<p>安装过程略（“增强型键盘驱动程序”不知道有什么用，先勾上）。</p>
<h2 id="下载-ubuntu-镜像">下载 Ubuntu 镜像</h2>
<p>是一种 Linux 发行版操作系统。</p>
<p><a
href="https://launchpad.net/ubuntu/+cdmirrors">下载页面（仓库集合）</a>，找到
China。</p>
<p>这里下载的是<code>ubuntu-22.04.3-live-server-amd64.iso</code>。</p>
<h2 id="在-vm-player-中新建虚拟机">在 VM Player 中新建虚拟机</h2>
<ol type="1">
<li><code>创建新虚拟机(N)</code></li>
<li><code>安装程序光盘文件(iso)(M)</code></li>
<li><code>浏览(R)</code>，选择下载的镜像文件，下一步。</li>
<li>设置虚拟机名称和位置，下一步。（我这里设置的是<code>Ubuntu100</code>和<code>D:\VMachines\Ubuntu100</code>）</li>
<li>指定磁盘容量，下一步。</li>
<li>自定义硬件（我这里把 CPU 改成了 4 核）。完成。</li>
</ol>
<p>你会看到：</p>
<p><img src="/blog/images/vm.png"></p>
<p>按回车开始安装 Ubuntu。</p>
<h2 id="安装-ubuntu">安装 Ubuntu</h2>
<ol type="1">
<li><p>语言选择，默认回车。</p></li>
<li><p>键盘布局选择，默认回车。</p></li>
<li><p>安装类型，默认回车。</p></li>
<li><p>网络，默认回车。</p></li>
<li><p>代理，默认回车。</p></li>
<li><p>配置镜像源，如果网络不好，改成</p>
<ul>
<li><p>清华源：<code>https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</code></p></li>
<li><p>南京源：<code>https://mirror.nju.edu.cn/ubuntu/</code></p></li>
<li><p>北邮源：<code>https://mirrors.bupt.edu.cn/ubuntu/</code></p>
<p>等均可。</p></li>
</ul></li>
<li><p>配置存储布局，默认选择<code>Done</code>，回车。</p></li>
<li><p>文件系统，<code>Done</code>，<code>Continue</code>。</p></li>
<li><p>设置用户名密码等。</p></li>
<li><p>是否升级到 Pro 版，默认不升级，<code>Continue</code>。</p></li>
<li><p>是否安装 OpenSSH server，先不安装。</p></li>
<li><p>是否安装其他东西，先都不选。</p></li>
<li><p>等待安装系统。</p></li>
<li><p>安装完成后，点击 VM Player
下方的“我已完成安装”，然后<code>Reboot Now</code>。</p></li>
</ol>
<p>输入用户名和密码登录 Ubuntu。注意输入密码默认是不回显的。</p>
<h2 id="设置虚拟机与真机的共享文件夹">设置虚拟机与真机的共享文件夹</h2>
<p>VM
的虚拟磁盘文件不好直接打开。有时候需要在虚拟机和真机之间互传文件，可以通过共享文件夹。</p>
<p>在 VM Player 里打开虚拟机设置-&gt;选项-&gt;共享文件夹。</p>
<p>我这里设置在<code>D:\VMachines\Shared</code>。</p>
<p>在虚拟机里的位置是<code>/mnt/hgfs/Shared</code>。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
  </entry>
  <entry>
    <title>普通十进制数转单精度浮点数</title>
    <url>/blog/2023/%E6%99%AE%E9%80%9A%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E5%8D%95%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0/</url>
    <content><![CDATA[<ul>
<li>在 IEEE 754 标准下</li>
</ul>
<span id="more"></span>
<p>单精度浮点数，即 32 位二进制浮点数，包含：</p>
<p>一位符号位 + 八位指数位 + 二十三位尾数位</p>
<h2 id="例一">例一</h2>
<p>以 <span class="math inline">\(0.1_{10}\)</span> 为例：</p>
<ol type="1">
<li><p>把十进制转换为二进制</p>
<p><span class="math inline">\(0.1 _{10} = 0.0\dot{0}01\dot{1}...
_{2}\)</span></p></li>
<li><p>用以 <span class="math inline">\(2_{10}\)</span>
为基数的科学计数法表示，并保证【尾数的小数点前是 <span
class="math inline">\(1_{2}\)</span>】</p>
<p><span class="math inline">\(= 1.\dot{1}00\dot{1}..._{2} \times
(2^{-4})_{10}\)</span></p>
<p>可以看到指数是 <span class="math inline">\(-4_{10}\)</span></p></li>
<li><p>计算指数位（又叫阶码），用指数加上偏移量 <span
class="math inline">\((2^{e-1}-1)_{10}\)</span></p>
<p>这里 <span class="math inline">\(e\)</span>
等于【用于表示指数位的位数】 <span
class="math inline">\(8_{10}\)</span>，所以偏移量为 <span
class="math inline">\(127_{10}\)</span></p>
<p>则阶码为 <span class="math inline">\(-4_{10} + 127_{10} =
123_{10}\)</span></p>
<p>阶码的二进制为 <code>0111 1011</code>，注意
<em>阶码始终为无符号整数</em></p></li>
<li><p>取科学计数法的【小数点后二十三位】作为【尾数位】，因为是无限的，所以要舍去一部分</p>
<p>它的前二十位是：<code>1001 1001 1001 1001 1001</code></p>
<p>二十一至二十八位是：<code>1001 1001</code></p>
<p>所以二十一至二十三位，要么取 <code>100</code>，要么取
<code>101</code>。</p>
<p>通常是舍入到最接近的，一样接近则偶数（末尾为
<code>0</code>）优先，这里 <code>101</code> 更接近。</p></li>
<li><p>把符号位连同阶码、尾数位缝合起来</p>
<p><code>0 | 0111 1011 | 1001 1001 1001 1001 1001 101</code></p></li>
</ol>
<h2 id="例二">例二</h2>
<p>以 <span class="math inline">\(12_{10} = 1.5_{10} \times
(2^{3})_{10}\)</span> 为例，和上面的步骤一样：</p>
<ol type="1">
<li><p>把十进制转换为二进制</p>
<p><span class="math inline">\(12 _{10} = 1100 _{2}\)</span></p></li>
<li><p>用以 <span class="math inline">\(2\)</span>
为基数的科学计数法表示，并保证【尾数的小数点前是 <span
class="math inline">\(1\)</span>】</p>
<p><span class="math inline">\(= 1.1_{2} \times (2^3)_{10}\)</span></p>
<p>可以看到指数是 <span class="math inline">\(3_{10}\)</span></p></li>
<li><p>计算指数位（又叫阶码），用指数加上偏移量 <span
class="math inline">\((2^{e-1}-1)_{10}\)</span></p>
<p>这里 <span class="math inline">\(e\)</span>
等于【用于表示指数位的位数】 <span
class="math inline">\(8_{10}\)</span>，所以偏移量为 <span
class="math inline">\(127_{10}\)</span></p>
<p>则阶码为 <span class="math inline">\(3_{10} + 127_{10} =
130_{10}\)</span></p>
<p>阶码的二进制为 <code>1000 0010</code>，注意
<em>阶码始终为无符号整数</em></p></li>
<li><p>取科学计数法的【小数点后二十三位】作为【尾数位】，因为是有限的，所以后面直接补零</p>
<p>小数点后二十三位是：<code>1000 0000 0000 0000 000</code></p></li>
<li><p>把符号位连同阶码、尾数位缝合起来</p>
<p><code>0 | 1000 0010 | 1000 0000 0000 0000 000</code></p></li>
</ol>
<h2 id="特殊情况">特殊情况</h2>
<p><a
href="/blog/2023/单精度浮点数的五种形式/">单精度浮点数的五种形式</a></p>
<h2 id="如何验证">如何验证</h2>
<ul>
<li><p><a
href="https://baseconvert.com/ieee-754-floating-point">在线转换</a></p></li>
<li><p><a href="/blog/2023/用GDB查看变量内存/">用 GDB
查看变量内存</a></p></li>
<li><p><a href="https://en.wikipedia.org/wiki/IEEE_754">Wikipedia</a> |
<a href="https://zh.wikipedia.org/wiki/IEEE_754">维基百科</a></p></li>
<li><p>获取国际标准文件</p>
<p>IEEE 754 标准是电气与电子工程师协会（Institute of Electrical and
Electronics Engineers）制定的关于浮点数表示和运算的标准。最新标准是 <a
href="https://standards.ieee.org/ieee/754/6210/">IEEE
754-2019</a>，对应国际标准 <a
href="https://www.iso.org/cms/%20render/live/en/sites/isoorg/contents/data/standard/08/09/80985.html">ISO/IEC
60559:2020</a>，预计下一次在 2028 年修订。 http://snti.ru/
这个网站分享了各种国际标准文件的磁力链接，但是可以免费下载的不全，IEC
的只有 61xxx。据说可以给站长发邮件要
<code>popov_al@perm.ru</code>，每个文件一刀乐。在 ISO 官网上下载需要 187
瑞士法郎，合 1000 多人民币。</p></li>
</ul>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
  </entry>
  <entry>
    <title>在手机上搭建Web服务器</title>
    <url>/blog/2023/%E5%9C%A8%E6%89%8B%E6%9C%BA%E4%B8%8A%E6%90%AD%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>使用的主要工具：</p>
<ul>
<li>Termux——模拟 Linux 环境</li>
<li>Flask——作为后端框架</li>
<li>Ngrok——内网穿透</li>
</ul>
<p>你需要：</p>
<ul>
<li>能够正常运行以上软件的安卓手机</li>
<li>最好有一台电脑</li>
</ul>
<span id="more"></span>
<p>在模拟的 Linux 环境下运行 Ngrok <strong>需要手机有 root
权限，仅用于解决<a
href="#在开始之前解决-dns-问题">这个问题</a></strong>。如果没有更好的，不使用
root 权限的方法的话，可以尝试<a href="#另外">在 Termux 上安装 Linux
发行版</a>。</p>
<p><a
href="/blog/2023/root%E6%89%8B%E6%9C%BA%E6%95%99%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8Magisk%EF%BC%89/">root
手机教程（使用 Magisk）</a></p>
<h2 id="termux模拟-linux-环境">Termux——模拟 Linux 环境</h2>
<p><a href="https://termux.dev/cn/index.html">Termux</a>
是一个在安卓手机上模拟 Linux 环境的 app。</p>
<p>适用于 Android &gt;= 7，无需手机 root。可以在 github 上<a
href="https://github.com/termux/termux-app/releases/">下载</a>。</p>
<p>Termux 模拟 Linux
环境的根目录在手机的<code>/data/data/com.termux/files/</code>。</p>
<h3 id="如果手机没有-root">如果手机没有 root：</h3>
<ul>
<li><p>在 termux 内，最多访问到上一级目录
<code>com.termux/</code>，无法访问<code>/data/</code>。</p></li>
<li><p>在 termux
外，使用文件管理器无法访问<code>/data/</code>。</p></li>
<li><p>在 termux 内访问手机 SD 卡，需使用命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">termux-setup-storage</span><br></pre></td></tr></table></figure>
<p>这会把 SD 卡目录<code>/storage/emulated/0/</code>链接到
<code>/data/data/com.termux/files/home/storage/shared/</code>。</p></li>
</ul>
<h3 id="如果手机已-root">如果手机已 root：</h3>
<p>可以直接使用<a href="https://mt2.cn/">MT
管理器</a>访问各个目录。这样转移文件比较方便。</p>
<h3 id="另外">另外</h3>
<p>上面针对的是 Termux 模拟的 Linux 环境。<strong>你可以使用 <a
href="https://wiki.termux.com/wiki/PRoot">PRoot</a> 或者 <a
href="https://github.com/2moe/tmoe">TMOE</a> 安装 Linux
发行版。</strong></p>
<h2 id="flask后端框架">Flask——后端框架</h2>
<p>Flask 是一个用 Python 编写的 Web 框架。<a
href="https://flask.palletsprojects.com/">官网</a> | <a
href="https://dormousehole.readthedocs.io/">中文文档</a></p>
<h3 id="安装-flask">安装 Flask</h3>
<p>首先在 Termux 上安装 Python：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pkg install python</span><br></pre></td></tr></table></figure>
<p>然后用 Python 的包管理工具 pip 安装 Flask：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install flask</span><br></pre></td></tr></table></figure>
<h3 id="在本地使用-flask">在本地使用 Flask</h3>
<ol type="1">
<li>在家目录下新建一个文件夹。名字随便取，用于存放代码：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/flask-app</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p>在文件夹里新建<code>app.py</code>文件——你可以在电脑上写好了传到手机，也可以用
MT 管理器写，还可以用 Vim 写。</p></li>
<li><p>编写代码：</p></li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, make_response</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="comment">#处理根路由的视图函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line"></span><br><span class="line">    <span class="comment">#创建 html 字符串</span></span><br><span class="line">    html_content = <span class="string">&quot;&lt;h1&gt;Hello, Flask!&lt;/h1&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#创建响应对象</span></span><br><span class="line">    response = make_response(html_content)</span><br><span class="line">    response.headers[<span class="string">&#x27;Content-Type&#x27;</span>] = <span class="string">&#x27;text/html&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#返回响应</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>在<code>flask-app</code>目录下运行：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python app.py &amp;</span><br></pre></td></tr></table></figure>
<p><code>&amp;</code>表示把程序放在后台运行。</p>
<p>你会看到：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"> * Serving Flask app &#x27;app&#x27;</span><br><span class="line"> * Debug mode: off</span><br><span class="line">WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.</span><br><span class="line"> * Running on http://127.0.0.1:5000</span><br><span class="line">Press CTRL+C to quit</span><br></pre></td></tr></table></figure>
<p>用浏览器访问<code>http://127.0.0.1:5000</code>，看到<code>Hello, Flask!</code>即为成功。</p>
<h3 id="在局域网内使用-flask">在局域网内使用 Flask</h3>
<p>指定<code>app.run()</code>里面的<code>host</code>和<code>port</code>参数，即可在
Wi-Fi 局域网内访问手机。</p>
<ol type="1">
<li><p>在手机设置里搜索（或者使用<code>ifconfig</code>命令），找到你手机的
ip 地址。比如是<code>192.168.1.2</code>。</p></li>
<li><p>把代码里的<code>app.run()</code>改为</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">app.run(host=<span class="string">&#x27;192.168.1.2&#x27;</span>, port=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure>
<p>端口号任意填不冲突就行，默认是<code>5000</code>。</p></li>
<li><p>如上文，运行。</p></li>
</ol>
<p>你可以在本机，或在局域网内任意设备的浏览器上访问<code>http://192.168.1.2:5000</code>。</p>
<h2 id="ngrok内网穿透">Ngrok——内网穿透</h2>
<p>我们搭建了“服务器”。但是没有公网 ip，无法接受来自局域网外的访问。</p>
<p>Ngrok
是一个用于创建安全隧道的工具，它可以将本地的服务器或应用程序暴露到公共互联网。</p>
<h3 id="安装-ngrok">安装 Ngrok</h3>
<ol type="1">
<li><p>查看 Termux 模拟 Linux 环境的 CPU 架构（跟随你手机的架构）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -m</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">getprop ro.product.cpu.abi</span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://ngrok.com/download">下载</a>对应架构的 Ngrok
到手机。（最新版 Ngrok
没有开源，使用<code>pkg install ngrok</code>找不到包，因此在官网上下载）</p></li>
<li><p>解压文件，并移动到<code>~/../usr/bin</code>目录。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar xvzf ~/storage/shared/[你下载的.tgz文件路径] -C ~/../usr/bin</span><br></pre></td></tr></table></figure>
<p>这里用家目录的上一级<code>~/../</code>表示 linux
环境根目录，也可以使用<code>$PREFIX</code>。如果直接使用<code>/</code>，Termux
会认为是手机的根目录。</p></li>
</ol>
<h3 id="在开始之前解决-dns-问题">在开始之前，解决 DNS 问题</h3>
<p>官网上的包，没有适配<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>
Termux。因此在我首次连接时，发生了连接错误。</p>
<p>在运行的同时打印日志：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ngrok http 5000 --log-level debug --<span class="built_in">log</span> stdout</span><br></pre></td></tr></table></figure>
<p>大部分内容略。关键在这里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read udp [::1]:43938-&gt;[::1]:53: read: connection refused</span><br></pre></td></tr></table></figure>
<p>在本地主机<code>[::1]</code>的<code>43938</code>端口和<code>53</code>端口之间，建立连接失败。<code>53</code>是
DNS 服务的端口，说明 DNS 查询出了问题。</p>
<p>Ngrok 是用 Go 语言写的，</p>
<blockquote>
<p>根据 src/net/dnsclient_unix.go，如果 /etc/resolv.conf 不存在，则选择
localhost:53 作为名称服务器。<a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
</blockquote>
<p>它想找<code>/etc/resolv.conf</code>查询
DNS，而在手机里找不到这个文件。进而向<code>localhost:53</code>发送 udp
数据包。手机的<code>53</code>端口没有开放，开启<code>1024</code>以下的端口需要
root 权限。</p>
<p>在 Termux
里有<code>resolv.conf</code>文件，在<code>$PREFIX/usr/etc/resolv.conf</code>。但是官方的包没有改路径，源码也没有开放。</p>
<p>我尝试修改 Ngrok 配置文件里的
<code>dns_resolver_ips</code>，但是没有用。</p>
<h4 id="解决方法">解决方法：</h4>
<p>把 Termux
的<code>resolv.conf</code>文件复制到手机<code>/etc/</code>目录下就行了。</p>
<ul>
<li><p>这需要 root 权限。</p></li>
<li><p><strong>这会修改<code>system</code>分区</strong>。如果手机升级，卸载面具前还要刷回原来的<code>system</code>；如果空间不够，可以删一些没用的系统预装软件数据，通常在<code>/system/app/</code>。</p></li>
<li><p>如果没有 root 权限，可以尝试<a href="#另外">在 Termux 上安装
Linux 发行版</a>。</p></li>
</ul>
<h3 id="使用-ngrok">使用 Ngrok</h3>
<p>先<a href="https://dashboard.ngrok.com/signup">注册账号</a>，然后<a
href="https://dashboard.ngrok.com">进入仪表板</a>。</p>
<h4 id="添加-authtoken-到配置文件">添加 Authtoken 到配置文件</h4>
<p>在本地服务器连接 Ngrok 服务器时，Authtoken 用于认证你的身份。</p>
<p>点击 <em>Your Authtoken</em>，你会看到你的 Authtoken。使用命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ngrok config add-authtoken [你的authtoken]</span><br></pre></td></tr></table></figure>
<p>这会向配置文件<code>~/.config/ngrok/ngrok.yml</code>里写入：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">authtoken:</span> [<span class="string">你的authtoken</span>]</span><br></pre></td></tr></table></figure>
<h4 id="添加-domain-和-edge">添加 Domain 和 Edge</h4>
<p>点击 <em>Domains</em>。Ngrok
应该会提醒你领取一个域名，像<code>[几个英文单词].ngrok-free.app</code>。这是在前端发送请求时的目标域名。</p>
<p>点击 <em>Edges</em>。点击 <em>+ New Edge</em> 按钮创建一个 Edge。</p>
<p>点击新建的
Edge，找到<code>edge=edghts_[一串字符]</code>，复制到手机备用。</p>
<h4 id="允许跨域请求">允许跨域请求</h4>
<p>Flask
可以根据用户的请求，动态生成前端代码。而如果前端代码单独放在另一台服务器上，比如
Github Pages——</p>
<p>从<code>github.io</code>向<code>ngrok-free.app</code>发送 HTTP
请求。由于两者不在同一域名下，浏览器为了用户安全，会拦截跨源请求。</p>
<p>解决方法是，在后端的响应里加上<a
href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">跨域资源共享（CORS）</a>头。</p>
<p>flask-cors 库可以给 Flask 的响应自动加上 CORS 头。<a
href="https://flask-cors.readthedocs.io/">flask-cors 文档</a></p>
<p>安装 flask-cors：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install flask-cors</span><br></pre></td></tr></table></figure>
<p>然后在<code>app.py</code>里加两行：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, make_response</span><br><span class="line"><span class="keyword">from</span> flask_cors <span class="keyword">import</span> CORS    <span class="comment">#&lt;----------</span></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">CORS(app)                      <span class="comment">#&lt;----------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="comment">#处理根路由的视图函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line"></span><br><span class="line">    <span class="comment">#创建 html 字符串</span></span><br><span class="line">    html_content = <span class="string">&quot;&lt;h1&gt;Hello, Flask!&lt;/h1&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#创建响应对象</span></span><br><span class="line">    response = make_response(html_content)</span><br><span class="line">    response.headers[<span class="string">&#x27;Content-Type&#x27;</span>] = <span class="string">&#x27;text/html&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#返回响应</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<h4 id="运行-ngrok">运行 Ngrok</h4>
<p>找到前面复制到手机上的<code>edge=edghts_[一串字符]</code>。</p>
<p>先启动 Flask 到后台，再运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ngrok tunnel --label edge=[一串字符] http://localhost:5000</span><br></pre></td></tr></table></figure>
<h4 id="测试发送-http-请求">测试发送 HTTP 请求</h4>
<ul>
<li><p>用 <a
href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">curl</a>
发送<code>GET</code>请求</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -v [你的Ngrok域名]</span><br></pre></td></tr></table></figure></li>
<li><p>在本地<code>file://</code>协议或其他域名下，用 <a
href="https://www.axios-http.cn/">axios</a> 发送跨域请求</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      axios</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">get</span>(<span class="string">&quot;https://你的Ngrok域名&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="后续处理">后续处理</h2>
<h3 id="保活">保活</h3>
<p>如果你想让服务器一直运行，在保持手机开机之外，还要：</p>
<ul>
<li><p>始终把 Termux 挂在后台，锁定，并忽略电池优化</p></li>
<li><p>使用<code>nohup</code>命令让程序不挂起（往下看）↓</p></li>
</ul>
<h3 id="启动服务器">启动服务器</h3>
<p>先启动 Termux，再依次启动 Flask 和 Ngrok。</p>
<p>可以向<code>$PREFIX/usr/etc/profile</code>文件中添加以下几行命令， 让
Termux 启动的同时自执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/flask-app</span><br><span class="line"><span class="built_in">nohup</span> python app.py &amp;</span><br><span class="line"><span class="built_in">nohup</span> ngrok tunnel --label edge=[一串字符] http://localhost:5000 &amp;</span><br></pre></td></tr></table></figure>
<h3 id="关闭服务器">关闭服务器</h3>
<p>使用<code>jobs</code>查看进程列表，<code>kill %[进程序号]</code>杀死进程。</p>
<p>当然，你也可以直接杀掉 Termux 的后台。</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="https://wiki.termux.com/wiki/Differences_from_Linux">Termux 与
Linux 的区别：https://wiki.termux.com/wiki/Differences_from_Linux</a><a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a href="https://stackoverflow.com/a/49315513">woohaha
的回答：https://stackoverflow.com/a/49315513</a><a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
  </entry>
  <entry>
    <title>概率统计中几个容易混淆的概念</title>
    <url>/blog/2023/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E4%B8%AD%E5%87%A0%E4%B8%AA%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p><span class="math inline">\(\alpha\)</span>分位点、置信度<span
class="math inline">\(1-\alpha\)</span>、显著性水平<span
class="math inline">\(\alpha\)</span>、区间估计的准确度与精确度、置信区间与假设检验的关系。</p>
<span id="more"></span>
<h2 id="alpha分位点"><span
class="math inline">\(\alpha\)</span>分位点</h2>
<p>简单地说，上<span class="math inline">\(\alpha\)</span>分位点<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>把随机变量的取值区间分成了两部分，随机变量取值落在右边的概率为<span
class="math inline">\(\alpha\)</span>。</p>
<p>即<span
class="math inline">\(P\{X&gt;上\alpha分位点\}=\alpha\)</span></p>
<p>从图像上看，比如：</p>
<p><img src="/blog/images/alpha-point.webp"></p>
<p>标准正态分布<span class="math inline">\(Z\sim
N(0,1)\)</span>的概率密度函数，它的函数图像上<span
class="math inline">\(\alpha\)</span>分位点(记作<span
class="math inline">\(z_\alpha\)</span>)以右与<span
class="math inline">\(x\)</span>轴围成的面积为<span
class="math inline">\(\alpha\)</span>。</p>
<p>相应地，下<span
class="math inline">\(\alpha\)</span>分位点把随机变量的取值区间分成了两部分，随机变量取值落在左边的概率为<span
class="math inline">\(\alpha\)</span>。</p>
<h2 id="置信度1-alpha">置信度<span
class="math inline">\(1-\alpha\)</span></h2>
<p><strong>参数估计</strong></p>
<p>总体的分布函数中有参数<span
class="math inline">\(\theta\)</span>未知。抽样，用样本估计参数<span
class="math inline">\(\theta\)</span>。</p>
<p>例如总体<span class="math inline">\(X\)</span>服从参数为<span
class="math inline">\(\theta\)</span>的指数分布，要估计<span
class="math inline">\(\theta\)</span></p>
<p><span
class="math inline">\(\theta\)</span>正好是总体均值，可以用样本均值估计总体均值。</p>
<p>抽三个样本<span
class="math inline">\(X_1,X_2,X_3\)</span>，样本均值<span
class="math inline">\(\bar{X}=\dfrac{X_1+X_2+X_3}{3}\)</span></p>
<p><span class="math inline">\(\theta\)</span>的估计量<span
class="math inline">\(\hat\theta=\dfrac{X_1+X_2+X_3}{3}\)</span></p>
<p><strong>区间估计</strong></p>
<p>总体的分布函数中有参数<span
class="math inline">\(\theta\)</span>未知。抽样，用样本估计参数<span
class="math inline">\(\theta\)</span>的<em>一个范围</em>。</p>
<p>这个范围<em>是一个随机区间</em>。</p>
<p>当这个随机区间包含<span
class="math inline">\(\theta\)</span>真值的概率大于等于<span
class="math inline">\(1-\alpha\)</span>时，这个区间是<span
class="math inline">\(\theta\)</span>的置信度为<span
class="math inline">\(1-\alpha\)</span>的置信区间。</p>
<blockquote>
<p>样本数目不变的情况下，做一百次试验，有95个置信区间包含了总体真值。置信度为95%<a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a></p>
</blockquote>
<h2
id="区间估计的准确度可靠性与精确度">区间估计的准确度（可靠性）与精确度</h2>
<p>置信度越大，置信区间越可靠，估计准确度越高。<a href="#fn3"
class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>置信区间越短，估计精确度越高。</p>
<h2 id="显著性水平alpha">显著性水平<span
class="math inline">\(\alpha\)</span></h2>
<p><strong>假设检验</strong></p>
<p>总体的分布函数未知或有参数未知。做假设、抽样，用样本判断是否接收假设。</p>
<p>例如正态总体<span
class="math inline">\(N(\mu,\sigma^2)\)</span>，<span
class="math inline">\(\mu\)</span>未知。做假设：</p>
<p><span class="math inline">\(H_0:\mu=\mu_0\)</span> <span
class="math inline">\(H_1:\mu\not=\mu_0\)</span></p>
<p><span
class="math inline">\(P\{拒绝H_0|H_0为真\}\le\alpha\)</span></p>
<p><span class="math inline">\(\alpha\)</span>即为显著性水平。</p>
<h2 id="置信区间与假设检验的关系">置信区间与假设检验的关系</h2>
<p>（显著性水平为<span
class="math inline">\(\alpha\)</span>的双边/单边假设检验问题的）<strong>接受域</strong></p>
<p>就是（参数的置信度为<span
class="math inline">\(1-\alpha\)</span>的双侧/单侧）<strong>置信区间</strong>。</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="https://www.zhihu.com/question/22420473/answer/1601002988">概率论分位点的含义？
- 知乎用户的回答 - 知乎</a><a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a
href="https://www.zhihu.com/question/20183513/answer/15023786">如何理解置信度？
- 邹日佳的回答 - 知乎</a><a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><a
href="https://www.zhihu.com/question/42770047/answer/149729398">置信区间的准确度和精确度如何确定以及它们之间的联系？
- 知乎</a><a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
]]></content>
      <categories>
        <category>概念</category>
      </categories>
  </entry>
  <entry>
    <title>第一篇文章</title>
    <url>/blog/2023/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>这是第一篇文章</p>
]]></content>
      <categories>
        <category>探索</category>
      </categories>
  </entry>
  <entry>
    <title>用GDB查看变量内存</title>
    <url>/blog/2023/%E7%94%A8GDB%E6%9F%A5%E7%9C%8B%E5%8F%98%E9%87%8F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p>起因是想验证浮点数的存储方式。</p>
<p><a
href="https://baseconvert.com/ieee-754-floating-point">这个网站</a>可以实现普通十进制数与
IEEE 754 浮点数的相互转换。</p>
<span id="more"></span>
<p>示例程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> num = <span class="number">1.7</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第六行打上断点，VSCode 开调试，在调试控制台里：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-<span class="built_in">exec</span> x/4tb &amp;num</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-exec</code> 执行命令</li>
<li><code>x</code> 查看内存</li>
<li><code>4</code> 输出 4 个单元
<ul>
<li>不写默认为 <code>1</code></li>
</ul></li>
<li><code>t</code> 以二进制形式输出
<ul>
<li><code>x</code> 十六进制</li>
</ul></li>
<li><code>b</code> 以【一个字节】为一个单元
<ul>
<li><code>h</code> 两个字节</li>
<li><code>w</code> 四个字节</li>
<li><code>g</code> 八个字节</li>
</ul></li>
<li><code>&amp;</code>取变量地址</li>
</ul>
<p>输出结果：</p>
<p><code>0x61fe1c: 10011010 10011001 11011001 00111111</code></p>
<p>从右往左排列后：</p>
<p><code>00111111 11011001 10011001 10011010</code></p>
<p>才是<code>float 1.7</code>的二进制表示。</p>
<p>还可以直接用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-<span class="built_in">exec</span> x/tw &amp;num</span><br></pre></td></tr></table></figure>
<p>输出四个字节，结果：</p>
<p><code>0x61fe1c: 00111111110110011001100110011010</code></p>
]]></content>
      <categories>
        <category>探索</category>
      </categories>
  </entry>
  <entry>
    <title>糊弄</title>
    <url>/blog/2023/%E7%B3%8A%E5%BC%84/</url>
    <content><![CDATA[<p>在粗略地、不系统地看了一些语词的解释后，我发现自己越来越会给自己找理由。</p>
<span id="more"></span>
<h2 id="犬儒的辩证法">犬儒的“辩证法”</h2>
<p>一切都是互相影响的，我把它换个词描述为薛定谔的蝴蝶效应。</p>
<p>我这篇博客发出来或者不发出来，未来都会因此受到影响。（如果不发出来，我会感觉心里憋得慌，难受）</p>
<p>如你所见，这篇博客发出来了，有人看或者没人看，未来都会因此受到影响。</p>
<p>并且，都会有“好”的一面（反思/批判地接受）和“坏”的一面（模仿/不加批判地接受），不管是对我自己还是对其他人。</p>
<p>特别是对我自己，我会有两种对立统一的行动（是行动吗？）：</p>
<ol type="1">
<li><p>自己在思想混乱时能想到这篇博客，以开始做“好”的事。如果只是想想而没有开始做，就转向
2。</p></li>
<li><p>自己做“反面教材”，以心安理得地做“坏”的事来让别人获得反思。（在做出决定的那一刻是这样的，事实上，在有了“辩证”的想法后，就不可能永远心安理得，又会转向
1）</p></li>
</ol>
<p>这种思想循环就是《草蛇惊一》的歌词“金蝉脱壳...山雨欲来风满楼”所描述的。心里想着塞翁失马，实际上是等待戈多。</p>
<h2 id="直觉主义">直觉主义</h2>
<p>在未明子的体系里是 1-3-4。</p>
<p>犹记得我在高考复习时、高考前夜、高考时、高考后都完全不紧张，连喜悦的心情也没有。</p>
<p>我只不过是看电影。</p>
<p>这是我中学时对待无良教师的想法。也许在不远的将来我被社会毒打时我会重新拾起这种想法。</p>
<h2 id="局限性">局限性</h2>
<p>我最初于《中国近现代史纲要》课本里看到这个词。</p>
<p>我遇到一个不好的老师，潜意识地认为之后所有老师都不好。</p>
<p>我是一个属于农村的孩子，最早的记忆却是在市区里生活。三年级之前，我在市区上学，转到县城之后，遍地的方言和粗口让我感到非常不适应。在初中刚开始，我甚至正好跟全班最没有素质、成绩最差的五个人分到了同一组。</p>
<p>这种游离于群体之外，认为“是不是只有我一个人对”的状态一直在持续。据我父母说那几年我也不和他们说话。</p>
<p>抑郁症。“没有倾诉对象”导致的。</p>
<p>根本就不是抑郁症，医生都没看出来，填几个问卷就判断是玉玉。但是为了有意识地忽略社恐的一面，却给自己贴上了标签，把【没有倾诉对象的失落感】映射为了【抑郁】。我自己能意识到，却说不出所以然。我是理科生，只有在网上搜哲学名词，搜到了唯心、唯我，嘛德还搜到了知乎懂哥讲的电子双缝干涉实验。（我也是懂哥，这也是我认为我博客可能带来“坏”的影响的原因）</p>
<p>于是在 2017
年末，我为了看到这场电影的结局，做了一个外人无法理解的决定。重新上学后好了一点，因为我心态变了，加上我移情到中文
VOCALOID 社区中了。上大学又是一个坎。我从没有像 2020
年那一样获得如此多的认同感——在网络虚拟空间内。然而在下半年上学时，我仍不愿意社交，并移情给了
B 站的中文 VOCALOID 的音乐制作人（俗称 P
主），在意识到做得太过时，我自闭了。然后又衣锦还乡了。然后鸽子变大了。然后是删稿，然后非常羞愧的主动请求招安。然后是表面告别、无尽的群除我佬和潜水。最后变成谎言。</p>
<p>在 2022 年听了平克弗洛伊德的《The Wall》，2023 年看了 JOJO
石之海之后，我更倾向于是“谁都没有错”，或者“大部分人都没有错”。特别是我对《The
Wall》有着非常强烈的共情，同时又造成了非常强烈的无力感和后遗症。（这时候可以听二手玫瑰的《公益歌曲》《穷光蛋》等以毒攻毒）</p>
<p>“无良老师”是因为“我和其他学生不同，不听话”，转学是因为父母工作原因要养活我。谁都没有错（在每个人内心当时的认知层面上），由于“认知的局限性”，最后却造成了悲剧。</p>
<p>然后，我又多了一个理由：现在的我做“错”事，是因为我不知道它是错事，俗称“师爷还不知道自己是个装糊涂的天才”。</p>
<h2 id="待补充">待补充</h2>
<ul>
<li><p>不可知论</p></li>
<li><p>符号学</p></li>
<li><p>后现代</p></li>
</ul>
<p>这终究是糊弄。我写日记，所以不是正经人。</p>
<blockquote>
<p>拒绝从善恶的结构性差异中汲取凝视的快感。
这种凝视是高效便捷的享乐循环。悬置真正的实践，把宝贵的时间投入虚空是可耻的。</p>
</blockquote>
]]></content>
      <categories>
        <category>共鸣</category>
      </categories>
  </entry>
  <entry>
    <title>用browser-sync实现在文件内容改变后立即刷新页面</title>
    <url>/blog/2023/%E7%94%A8browser-sync%E5%AE%9E%E7%8E%B0%E5%9C%A8%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%94%B9%E5%8F%98%E5%90%8E%E7%AB%8B%E5%8D%B3%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<p>起因是：</p>
<p>不管是直接打开 html
文件，还是用<code>python -m http.server 8000 --bind 127.0.0.1</code>，在修改保存
html 文件后浏览器都不能立马刷新。</p>
<span id="more"></span>
<ol type="1">
<li><p>安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install browser-sync</span><br></pre></td></tr></table></figure>
<p>安装到想作为服务器根目录的文件夹。以前觉得全局安装好，现在暂时觉得本地安装好。（据说用
Flask 也能实现立即刷新，用搜到的方法结果版本不匹配）</p></li>
<li><p>运行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npx browser-sync start --server --files <span class="string">&quot;.&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>--files</code> 后指定要监视的文件。</p>
<p><code>.</code> 表示监视当前目录以及子目录下的所有文件。</p>
<p>可以改成 <code>*.html</code>，<code>public/*.*</code> 等。</p></li>
</ol>
<p>html
文件里至少得有一对<code>&lt;body&gt;</code>标签，要么没法自动刷新。</p>
<p>在没有修改文件内容，只 <code>Ctrl + S</code>
保存时也会刷新，在命令行会输出
<code>File event [change]</code>，只不过看不出来。</p>
<p>好像和直接通过浏览器来刷新不一样，因为我在选项卡上没看到加载动画。</p>
]]></content>
      <categories>
        <category>探索</category>
      </categories>
  </entry>
  <entry>
    <title>让博客commit前的工作更简单</title>
    <url>/blog/2023/%E8%AE%A9%E5%8D%9A%E5%AE%A2commit%E5%89%8D%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9B%B4%E7%AE%80%E5%8D%95/</url>
    <content><![CDATA[<p>起因是，我是把博客代码分两个仓库存的。需要做很多重复的工作。</p>
<p>于是我写了两个 bat 文件。</p>
<span id="more"></span>
<p>起因是，我是把博客代码分两个仓库存的：</p>
<ul>
<li><p><code>blog-source</code>存 Hexo 框架源码，NexT
主题源码和自己的部分（更改后的配置文件、md 文档、图片等）</p></li>
<li><p><code>blog</code>存渲染之后的网页，分支是<code>gh-pages</code></p></li>
</ul>
<p>这就造成在 commit 前，我需要做以下工作：</p>
<ol type="1">
<li><p>在<code>blog-source</code>文件夹里先打开本地预览服务器。</p></li>
<li><p>点击链接，在浏览器里打开。</p></li>
<li><p>预览没问题，渲染网页。</p></li>
<li><p>删除<code>blog</code>文件夹里除了<code>.git</code>外的所有文件和文件夹。</p></li>
<li><p>把渲染的网页从<code>blog-source/public/</code>转移到<code>blog</code>文件夹里。</p></li>
<li><p>清除<code>blog-source</code>文件夹里渲染的网页。</p></li>
</ol>
<p>手动操作了十几天后很烦，于是我写了两个 bat 文件：</p>
<p><code>bs.bat</code> 做第 1-2 步</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /d d:\repo\blog-source</span><br><span class="line"><span class="built_in">start</span> http://localhost:<span class="number">4000</span>/blog/</span><br><span class="line"><span class="keyword">call</span> npx hexo s</span><br></pre></td></tr></table></figure>
<p><code>bg.bat</code> 做第 3-6 步</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:: 删除旧文件</span><br><span class="line"><span class="built_in">cd</span> /d d:\repo\blog</span><br><span class="line">git rm -r *</span><br><span class="line">:: 渲染新文件</span><br><span class="line"><span class="built_in">cd</span> ..\blog-source</span><br><span class="line"><span class="keyword">call</span> npx hexo g</span><br><span class="line">:: 转移新文件</span><br><span class="line"><span class="built_in">xcopy</span> public ..\blog /s /e</span><br><span class="line"><span class="keyword">call</span> npx hexo clean</span><br></pre></td></tr></table></figure>
<p>再建一个专门存 bat 的文件夹，把它添加到环境变量
PATH。这样在任一文件夹下都可以做第 1-6 步了。</p>
<p>commit 我用的是 GitHub Desktop，暂时没有换的必要。</p>
]]></content>
      <categories>
        <category>探索</category>
      </categories>
  </entry>
  <entry>
    <title>踩坑记录（1）</title>
    <url>/blog/2023/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p>做数据库课设时，我试图修改一个外键的删除规则和更新规则为<code>CASCADE</code>。</p>
<p>SQL语句执行成功了，然而刷新后它的规则又都变回了<code>RESTRICT</code>。
<span id="more"></span></p>
<p>我使用的是 MySQL + DBeaver。</p>
<p>建立外键时，选择的删除规则和更新规则是无动作（默认）。</p>
<p>建立后，MySQL把它们设为了<code>RESTRICT</code>。</p>
<p>由于一些麻烦的原因，我想把它们改成<code>CASCADE</code>，于是出现了上面的情况。</p>
<p>DBeaver给出的SQL语句是把外键删了重建： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dbkeshe.student <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY student_FK;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dbkeshe.student <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> student_FK <span class="keyword">FOREIGN</span> KEY (CLASS_NO) <span class="keyword">REFERENCES</span> dbkeshe.class(CLASS_NO) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE;</span><br></pre></td></tr></table></figure>
准确说不是刷新后变回，在当前的外键窗口刷新是不变的，关闭窗口后重新打开就变了。我以为是DBeaver的问题，又在命令行里执行了一遍，还是会变回<code>RESTRICT</code>。关键是MySQL还没报错。</p>
<p>网上搜了一下，没有找到类似的情况发生过。</p>
<p>我又尝试把所有的外键约束删了，然后再重建，还是不行。把所有的外键约束和索引删了，然后再重建，还是不行。到最后还是没有找到原因。</p>
<p>我把旧数据库dump出来的sql文件外键约束后面全部加上<code>ON DELETE CASCADE ON UPDATE CASCADE</code>，再用sql文件重建一个数据库，这回成功了。然后...我数天后打开它又变回去了？？？并且重建后还是会变回去。</p>
<p>除了手动重建数据库，最后有一个不得已而为之的方法：要想实现级联更新，暂时关闭外键约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> foreign_key_checks <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>然后把要级联更新的所有表都手动更新一遍，再打开约束...</p>
]]></content>
      <categories>
        <category>探索</category>
      </categories>
  </entry>
  <entry>
    <title>说的道理</title>
    <url>/blog/2023/%E8%AF%B4%E7%9A%84%E9%81%93%E7%90%86/</url>
    <content><![CDATA[<ul>
<li>如何应对拖延</li>
</ul>
<span id="more"></span>
<h2 id="如何应对拖延">如何应对拖延</h2>
<p>先写最重要的部分，不要迷失在语言表达，想梗和想标题上。</p>
<p>有想写的马上写，可以先不发，或者先发一部分，后来再拼起来。</p>
<p>有想做的马上做，可以先做一部分。</p>
<p>有时候脑子里总在想一个标题，其实自己根本对要写的内容都没有明确的理解，只是觉得这个标题特别吊，光把时间用到“预想写完之后的结果”了。</p>
<p>从<a
href="https://www.ruanyifeng.com/blog/2019/08/weekly-issue-69.html">阮一峰的一篇文章</a>里看到，博客需要先写快，后写好。</p>
<p>从<a href="https://space.bilibili.com/230711744/article">B
站的一篇笔记</a>看到，满足欲望不是什么坏事。在没有特别重要的事情的情况下，先把最想做的做了。</p>
<iframe frameborder="no" width="100%" height="86" src="//music.163.com/outchain/player?type=2&amp;id=386830&amp;auto=1&amp;height=66">
</iframe>
<p>睡一觉起来发现海港没了</p>
]]></content>
      <categories>
        <category>共鸣</category>
      </categories>
  </entry>
  <entry>
    <title>踩坑记录（2）</title>
    <url>/blog/2023/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<p>Web大作业要求提交网站代码，而博客的html在本地打开会加载不出来css和js。这是文件路径的问题。
<span id="more"></span></p>
<p>hexo生成的html文件，里面引用文件的路径是这样的：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;/blog/css/<span class="selector-tag">main</span><span class="selector-class">.css</span>&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>在线打开一切正常，因为这里的根目录是网站根目录。而用浏览器直接打开本地html文件时，浏览器会认为它是文件根目录：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">href=&quot;file:///blog/css/main.css<span class="string">&quot;</span></span><br></pre></td></tr></table></figure>
<p>正确的预览方法是使用命令<code>hexo s</code>并在<code>http://localhost:4000/blog/</code>预览。</p>
<p>不过作业是要提交的，为了能直接预览只能手动改路径了。把所有html里引用的文件地址都替换成相应的相对地址就行了。</p>
<p>但是还有一个问题。这样引用的css和js正常了，页面跳转链接不正常：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;./2023/05/30/文章标题/&#x27;</span>&gt;</span>文章标题<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在线打开，浏览器会从<code>/</code>自动跳转到<code>index.html</code>。而本地则不会，浏览器会打开<code>index.html</code>所在的文件夹。</p>
<p><a
href="https://chz613.github.io/post/hexo-next-url-html-suffix.html">这篇文章</a>给出了解决方法，就是修改配置文件里的<code>permalink:</code>使生成文章的链接带<code>.html</code>后缀。但是这样只有文章的结尾带后缀，其他页面还是不带。修改其他页面需要修改hexo和next组件里的脚本。而脚本已经更新过，不是当时的了。考虑到未来有可能还会更新，和页面路径的统一性，还是不改配置了。手动改html吧。</p>
]]></content>
      <categories>
        <category>探索</category>
      </categories>
  </entry>
  <entry>
    <title>踩坑记录（3）</title>
    <url>/blog/2023/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<p>这里记录的是我用 hexo
部署博客时踩的一些坑的正确解决方法。同类型的有<a
href="https://ruofancooh.github.io/blog/2023/05/27/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%EF%BC%882%EF%BC%89/">踩坑记录（2）</a>。</p>
<span id="more"></span>
<h2 id="node-模块安装路径问题">node 模块安装路径问题</h2>
<p>npm 安装模块有两种安装方式：本地安装和全局安装。</p>
<p>本地安装：<code>npm install &lt;pageName&gt;</code>，安装在当前文件夹下的
node_modules 目录。</p>
<p>全局安装：<code>npm install &lt;pageName&gt; -g</code>，默认安装在<code>C:\Users\用户名\AppData\Roaming\npm</code>下。这好吗，这不好。</p>
<p>可使用<code>npm config get prefix</code>查看当前全局安装路径。</p>
<p>使用<code>npm config set prefix "路径"</code>更改全局安装路径。</p>
<p>设置完后不要忘了改环境变量。</p>
<h2 id="把博客放在子文件夹blog-下">把博客放在子文件夹/blog 下：</h2>
<ul>
<li><p>github 新建一个名为 blog 的仓库，branch 为 gh-pages</p></li>
<li><p>更改 hexo 的_config.yml 文件以下项：</p></li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://ruofancooh.github.io/blog</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/blog/</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/ruofancooh/blog</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">gh-pages</span></span><br></pre></td></tr></table></figure>
<h2 id="hexo-更换-next-主题">hexo 更换 next 主题</h2>
<p>在博客目录下运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>更改站点配置文件中<code>theme</code>字段的值为<code>next</code></p>
<h2 id="next-主题设置背景图片">next 主题设置背景图片</h2>
<p><strong><em>现在我觉得没必要，简洁点好。</em></strong></p>
<p>把主题配置文件中的<code>custom_file_path:</code>下的<code>style</code>取消注释</p>
<p>在<code>next/source/</code>下新建<code>_data</code>目录，目录里新建<code>styles.styl</code>文件。</p>
<p>在<code>styles.styl</code>文件中设置：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="comment">/*注意用相对路径，然后在相应的路径下放图片*/</span></span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">../images/background.png</span>);</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat; <span class="comment">/*不重复*/</span></span><br><span class="line">  <span class="attribute">background-attachment</span>: fixed; <span class="comment">/*不滚动*/</span></span><br><span class="line">  <span class="attribute">background-size</span>: cover; <span class="comment">/*图片尺寸不拉伸*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在博客中插入图片">在博客中插入图片</h2>
<p><strong><em>现在我觉得图片单独放一个文件夹，直接在 md
文档里用<code>&lt;img&gt;</code>标签引入比较好。暂时没必要用图床。</em></strong></p>
<p>hexo 配置文件中修改：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><code>_posts</code>文件夹下新建与 md 文档同名的文件夹，放入图片。在
md 文档中用</p>
<p><code>&#123;% asset_img filename.png %&#125;</code>引入图片。</p>
<h2 id="更换-markdown-渲染器">更换 markdown 渲染器</h2>
<p>为使博客支持 latex，卸载自带渲染器并更换渲染器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked</span><br><span class="line">npm i hexo-renderer-pandoc</span><br></pre></td></tr></table></figure>
<p>需要额外<a href="https://github.com/jgm/pandoc/releases/latest">安装
pandoc</a></p>
<p>更改 next 配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="attr">every_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong><em>现在我会把<code>every_page</code>改成<code>flase</code>，需要用时在
md 文档头部加上<code>mathjax: true</code>。</em></strong></p>
]]></content>
      <categories>
        <category>探索</category>
      </categories>
  </entry>
</search>
